// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'field_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$FieldType {
  bool get isNullable => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FieldTypeCopyWith<FieldType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FieldTypeCopyWith<$Res> {
  factory $FieldTypeCopyWith(FieldType value, $Res Function(FieldType) then) =
      _$FieldTypeCopyWithImpl<$Res, FieldType>;
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class _$FieldTypeCopyWithImpl<$Res, $Val extends FieldType>
    implements $FieldTypeCopyWith<$Res> {
  _$FieldTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_value.copyWith(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FieldTypeStringImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeStringImplCopyWith(_$FieldTypeStringImpl value,
          $Res Function(_$FieldTypeStringImpl) then) =
      __$$FieldTypeStringImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeStringImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeStringImpl>
    implements _$$FieldTypeStringImplCopyWith<$Res> {
  __$$FieldTypeStringImplCopyWithImpl(
      _$FieldTypeStringImpl _value, $Res Function(_$FieldTypeStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeStringImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeStringImpl implements FieldTypeString {
  const _$FieldTypeStringImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.string(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeStringImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeStringImplCopyWith<_$FieldTypeStringImpl> get copyWith =>
      __$$FieldTypeStringImplCopyWithImpl<_$FieldTypeStringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return string(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return string?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class FieldTypeString implements FieldType {
  const factory FieldTypeString({required final bool isNullable}) =
      _$FieldTypeStringImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeStringImplCopyWith<_$FieldTypeStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeIntImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeIntImplCopyWith(
          _$FieldTypeIntImpl value, $Res Function(_$FieldTypeIntImpl) then) =
      __$$FieldTypeIntImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeIntImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeIntImpl>
    implements _$$FieldTypeIntImplCopyWith<$Res> {
  __$$FieldTypeIntImplCopyWithImpl(
      _$FieldTypeIntImpl _value, $Res Function(_$FieldTypeIntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeIntImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeIntImpl implements FieldTypeInt {
  const _$FieldTypeIntImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.int(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeIntImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeIntImplCopyWith<_$FieldTypeIntImpl> get copyWith =>
      __$$FieldTypeIntImplCopyWithImpl<_$FieldTypeIntImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return int(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return int?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return int(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return int?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(this);
    }
    return orElse();
  }
}

abstract class FieldTypeInt implements FieldType {
  const factory FieldTypeInt({required final bool isNullable}) =
      _$FieldTypeIntImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeIntImplCopyWith<_$FieldTypeIntImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeDoubleImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeDoubleImplCopyWith(_$FieldTypeDoubleImpl value,
          $Res Function(_$FieldTypeDoubleImpl) then) =
      __$$FieldTypeDoubleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeDoubleImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeDoubleImpl>
    implements _$$FieldTypeDoubleImplCopyWith<$Res> {
  __$$FieldTypeDoubleImplCopyWithImpl(
      _$FieldTypeDoubleImpl _value, $Res Function(_$FieldTypeDoubleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeDoubleImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeDoubleImpl implements FieldTypeDouble {
  const _$FieldTypeDoubleImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.double(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeDoubleImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeDoubleImplCopyWith<_$FieldTypeDoubleImpl> get copyWith =>
      __$$FieldTypeDoubleImplCopyWithImpl<_$FieldTypeDoubleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return double(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return double?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return double(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return double?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(this);
    }
    return orElse();
  }
}

abstract class FieldTypeDouble implements FieldType {
  const factory FieldTypeDouble({required final bool isNullable}) =
      _$FieldTypeDoubleImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeDoubleImplCopyWith<_$FieldTypeDoubleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeBoolImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeBoolImplCopyWith(
          _$FieldTypeBoolImpl value, $Res Function(_$FieldTypeBoolImpl) then) =
      __$$FieldTypeBoolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeBoolImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeBoolImpl>
    implements _$$FieldTypeBoolImplCopyWith<$Res> {
  __$$FieldTypeBoolImplCopyWithImpl(
      _$FieldTypeBoolImpl _value, $Res Function(_$FieldTypeBoolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeBoolImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeBoolImpl implements FieldTypeBool {
  const _$FieldTypeBoolImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.bool(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeBoolImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeBoolImplCopyWith<_$FieldTypeBoolImpl> get copyWith =>
      __$$FieldTypeBoolImplCopyWithImpl<_$FieldTypeBoolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return bool(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return bool?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return bool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return bool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(this);
    }
    return orElse();
  }
}

abstract class FieldTypeBool implements FieldType {
  const factory FieldTypeBool({required final bool isNullable}) =
      _$FieldTypeBoolImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeBoolImplCopyWith<_$FieldTypeBoolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeTimestampImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeTimestampImplCopyWith(_$FieldTypeTimestampImpl value,
          $Res Function(_$FieldTypeTimestampImpl) then) =
      __$$FieldTypeTimestampImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeTimestampImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeTimestampImpl>
    implements _$$FieldTypeTimestampImplCopyWith<$Res> {
  __$$FieldTypeTimestampImplCopyWithImpl(_$FieldTypeTimestampImpl _value,
      $Res Function(_$FieldTypeTimestampImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeTimestampImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeTimestampImpl implements FieldTypeTimestamp {
  const _$FieldTypeTimestampImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.timestamp(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeTimestampImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeTimestampImplCopyWith<_$FieldTypeTimestampImpl> get copyWith =>
      __$$FieldTypeTimestampImplCopyWithImpl<_$FieldTypeTimestampImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return timestamp(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return timestamp?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (timestamp != null) {
      return timestamp(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return timestamp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return timestamp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (timestamp != null) {
      return timestamp(this);
    }
    return orElse();
  }
}

abstract class FieldTypeTimestamp implements FieldType {
  const factory FieldTypeTimestamp({required final bool isNullable}) =
      _$FieldTypeTimestampImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeTimestampImplCopyWith<_$FieldTypeTimestampImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeDateTimeImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeDateTimeImplCopyWith(_$FieldTypeDateTimeImpl value,
          $Res Function(_$FieldTypeDateTimeImpl) then) =
      __$$FieldTypeDateTimeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeDateTimeImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeDateTimeImpl>
    implements _$$FieldTypeDateTimeImplCopyWith<$Res> {
  __$$FieldTypeDateTimeImplCopyWithImpl(_$FieldTypeDateTimeImpl _value,
      $Res Function(_$FieldTypeDateTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeDateTimeImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeDateTimeImpl implements FieldTypeDateTime {
  const _$FieldTypeDateTimeImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.dateTime(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeDateTimeImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeDateTimeImplCopyWith<_$FieldTypeDateTimeImpl> get copyWith =>
      __$$FieldTypeDateTimeImplCopyWithImpl<_$FieldTypeDateTimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return dateTime(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return dateTime?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class FieldTypeDateTime implements FieldType {
  const factory FieldTypeDateTime({required final bool isNullable}) =
      _$FieldTypeDateTimeImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeDateTimeImplCopyWith<_$FieldTypeDateTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeDocumentReferenceImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeDocumentReferenceImplCopyWith(
          _$FieldTypeDocumentReferenceImpl value,
          $Res Function(_$FieldTypeDocumentReferenceImpl) then) =
      __$$FieldTypeDocumentReferenceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isNullable});
}

/// @nodoc
class __$$FieldTypeDocumentReferenceImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeDocumentReferenceImpl>
    implements _$$FieldTypeDocumentReferenceImplCopyWith<$Res> {
  __$$FieldTypeDocumentReferenceImplCopyWithImpl(
      _$FieldTypeDocumentReferenceImpl _value,
      $Res Function(_$FieldTypeDocumentReferenceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeDocumentReferenceImpl(
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeDocumentReferenceImpl implements FieldTypeDocumentReference {
  const _$FieldTypeDocumentReferenceImpl({required this.isNullable});

  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.documentReference(isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeDocumentReferenceImpl &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeDocumentReferenceImplCopyWith<_$FieldTypeDocumentReferenceImpl>
      get copyWith => __$$FieldTypeDocumentReferenceImplCopyWithImpl<
          _$FieldTypeDocumentReferenceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return documentReference(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return documentReference?.call(isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (documentReference != null) {
      return documentReference(isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return documentReference(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return documentReference?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (documentReference != null) {
      return documentReference(this);
    }
    return orElse();
  }
}

abstract class FieldTypeDocumentReference implements FieldType {
  const factory FieldTypeDocumentReference({required final bool isNullable}) =
      _$FieldTypeDocumentReferenceImpl;

  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeDocumentReferenceImplCopyWith<_$FieldTypeDocumentReferenceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeCustomClassImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeCustomClassImplCopyWith(_$FieldTypeCustomClassImpl value,
          $Res Function(_$FieldTypeCustomClassImpl) then) =
      __$$FieldTypeCustomClassImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String className, String path, bool isNullable});
}

/// @nodoc
class __$$FieldTypeCustomClassImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeCustomClassImpl>
    implements _$$FieldTypeCustomClassImplCopyWith<$Res> {
  __$$FieldTypeCustomClassImplCopyWithImpl(_$FieldTypeCustomClassImpl _value,
      $Res Function(_$FieldTypeCustomClassImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? className = null,
    Object? path = null,
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeCustomClassImpl(
      className: null == className
          ? _value.className
          : className // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldTypeCustomClassImpl implements FieldTypeCustomClass {
  const _$FieldTypeCustomClassImpl(
      {required this.className, required this.path, required this.isNullable});

  @override
  final String className;
  @override
  final String path;
  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.customClass(className: $className, path: $path, isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeCustomClassImpl &&
            (identical(other.className, className) ||
                other.className == className) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, className, path, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeCustomClassImplCopyWith<_$FieldTypeCustomClassImpl>
      get copyWith =>
          __$$FieldTypeCustomClassImplCopyWithImpl<_$FieldTypeCustomClassImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return customClass(className, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return customClass?.call(className, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (customClass != null) {
      return customClass(className, path, isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return customClass(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return customClass?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (customClass != null) {
      return customClass(this);
    }
    return orElse();
  }
}

abstract class FieldTypeCustomClass implements FieldType {
  const factory FieldTypeCustomClass(
      {required final String className,
      required final String path,
      required final bool isNullable}) = _$FieldTypeCustomClassImpl;

  String get className;
  String get path;
  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeCustomClassImplCopyWith<_$FieldTypeCustomClassImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeListImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeListImplCopyWith(
          _$FieldTypeListImpl value, $Res Function(_$FieldTypeListImpl) then) =
      __$$FieldTypeListImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({FieldType subType, String? path, bool isNullable});

  $FieldTypeCopyWith<$Res> get subType;
}

/// @nodoc
class __$$FieldTypeListImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeListImpl>
    implements _$$FieldTypeListImplCopyWith<$Res> {
  __$$FieldTypeListImplCopyWithImpl(
      _$FieldTypeListImpl _value, $Res Function(_$FieldTypeListImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subType = null,
    Object? path = freezed,
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeListImpl(
      subType: null == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as FieldType,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FieldTypeCopyWith<$Res> get subType {
    return $FieldTypeCopyWith<$Res>(_value.subType, (value) {
      return _then(_value.copyWith(subType: value));
    });
  }
}

/// @nodoc

class _$FieldTypeListImpl implements FieldTypeList {
  const _$FieldTypeListImpl(
      {required this.subType, required this.path, required this.isNullable});

  @override
  final FieldType subType;
  @override
  final String? path;
  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.list(subType: $subType, path: $path, isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeListImpl &&
            (identical(other.subType, subType) || other.subType == subType) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, subType, path, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeListImplCopyWith<_$FieldTypeListImpl> get copyWith =>
      __$$FieldTypeListImplCopyWithImpl<_$FieldTypeListImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return list(subType, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return list?.call(subType, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(subType, path, isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return list(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return list?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(this);
    }
    return orElse();
  }
}

abstract class FieldTypeList implements FieldType {
  const factory FieldTypeList(
      {required final FieldType subType,
      required final String? path,
      required final bool isNullable}) = _$FieldTypeListImpl;

  FieldType get subType;
  String? get path;
  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeListImplCopyWith<_$FieldTypeListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldTypeMapImplCopyWith<$Res>
    implements $FieldTypeCopyWith<$Res> {
  factory _$$FieldTypeMapImplCopyWith(
          _$FieldTypeMapImpl value, $Res Function(_$FieldTypeMapImpl) then) =
      __$$FieldTypeMapImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({FieldType subType, String? path, bool isNullable});

  $FieldTypeCopyWith<$Res> get subType;
}

/// @nodoc
class __$$FieldTypeMapImplCopyWithImpl<$Res>
    extends _$FieldTypeCopyWithImpl<$Res, _$FieldTypeMapImpl>
    implements _$$FieldTypeMapImplCopyWith<$Res> {
  __$$FieldTypeMapImplCopyWithImpl(
      _$FieldTypeMapImpl _value, $Res Function(_$FieldTypeMapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subType = null,
    Object? path = freezed,
    Object? isNullable = null,
  }) {
    return _then(_$FieldTypeMapImpl(
      subType: null == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as FieldType,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      isNullable: null == isNullable
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FieldTypeCopyWith<$Res> get subType {
    return $FieldTypeCopyWith<$Res>(_value.subType, (value) {
      return _then(_value.copyWith(subType: value));
    });
  }
}

/// @nodoc

class _$FieldTypeMapImpl implements FieldTypeMap {
  const _$FieldTypeMapImpl(
      {required this.subType, required this.path, required this.isNullable});

  @override
  final FieldType subType;
  @override
  final String? path;
  @override
  final bool isNullable;

  @override
  String toString() {
    return 'FieldType.map(subType: $subType, path: $path, isNullable: $isNullable)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldTypeMapImpl &&
            (identical(other.subType, subType) || other.subType == subType) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.isNullable, isNullable) ||
                other.isNullable == isNullable));
  }

  @override
  int get hashCode => Object.hash(runtimeType, subType, path, isNullable);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldTypeMapImplCopyWith<_$FieldTypeMapImpl> get copyWith =>
      __$$FieldTypeMapImplCopyWithImpl<_$FieldTypeMapImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool isNullable) string,
    required TResult Function(bool isNullable) int,
    required TResult Function(bool isNullable) double,
    required TResult Function(bool isNullable) bool,
    required TResult Function(bool isNullable) timestamp,
    required TResult Function(bool isNullable) dateTime,
    required TResult Function(bool isNullable) documentReference,
    required TResult Function(String className, String path, bool isNullable)
        customClass,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        list,
    required TResult Function(FieldType subType, String? path, bool isNullable)
        map,
  }) {
    return map(subType, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool isNullable)? string,
    TResult? Function(bool isNullable)? int,
    TResult? Function(bool isNullable)? double,
    TResult? Function(bool isNullable)? bool,
    TResult? Function(bool isNullable)? timestamp,
    TResult? Function(bool isNullable)? dateTime,
    TResult? Function(bool isNullable)? documentReference,
    TResult? Function(String className, String path, bool isNullable)?
        customClass,
    TResult? Function(FieldType subType, String? path, bool isNullable)? list,
    TResult? Function(FieldType subType, String? path, bool isNullable)? map,
  }) {
    return map?.call(subType, path, isNullable);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool isNullable)? string,
    TResult Function(bool isNullable)? int,
    TResult Function(bool isNullable)? double,
    TResult Function(bool isNullable)? bool,
    TResult Function(bool isNullable)? timestamp,
    TResult Function(bool isNullable)? dateTime,
    TResult Function(bool isNullable)? documentReference,
    TResult Function(String className, String path, bool isNullable)?
        customClass,
    TResult Function(FieldType subType, String? path, bool isNullable)? list,
    TResult Function(FieldType subType, String? path, bool isNullable)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(subType, path, isNullable);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldTypeString value) string,
    required TResult Function(FieldTypeInt value) int,
    required TResult Function(FieldTypeDouble value) double,
    required TResult Function(FieldTypeBool value) bool,
    required TResult Function(FieldTypeTimestamp value) timestamp,
    required TResult Function(FieldTypeDateTime value) dateTime,
    required TResult Function(FieldTypeDocumentReference value)
        documentReference,
    required TResult Function(FieldTypeCustomClass value) customClass,
    required TResult Function(FieldTypeList value) list,
    required TResult Function(FieldTypeMap value) map,
  }) {
    return map(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldTypeString value)? string,
    TResult? Function(FieldTypeInt value)? int,
    TResult? Function(FieldTypeDouble value)? double,
    TResult? Function(FieldTypeBool value)? bool,
    TResult? Function(FieldTypeTimestamp value)? timestamp,
    TResult? Function(FieldTypeDateTime value)? dateTime,
    TResult? Function(FieldTypeDocumentReference value)? documentReference,
    TResult? Function(FieldTypeCustomClass value)? customClass,
    TResult? Function(FieldTypeList value)? list,
    TResult? Function(FieldTypeMap value)? map,
  }) {
    return map?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldTypeString value)? string,
    TResult Function(FieldTypeInt value)? int,
    TResult Function(FieldTypeDouble value)? double,
    TResult Function(FieldTypeBool value)? bool,
    TResult Function(FieldTypeTimestamp value)? timestamp,
    TResult Function(FieldTypeDateTime value)? dateTime,
    TResult Function(FieldTypeDocumentReference value)? documentReference,
    TResult Function(FieldTypeCustomClass value)? customClass,
    TResult Function(FieldTypeList value)? list,
    TResult Function(FieldTypeMap value)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(this);
    }
    return orElse();
  }
}

abstract class FieldTypeMap implements FieldType {
  const factory FieldTypeMap(
      {required final FieldType subType,
      required final String? path,
      required final bool isNullable}) = _$FieldTypeMapImpl;

  FieldType get subType;
  String? get path;
  @override
  bool get isNullable;
  @override
  @JsonKey(ignore: true)
  _$$FieldTypeMapImplCopyWith<_$FieldTypeMapImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
